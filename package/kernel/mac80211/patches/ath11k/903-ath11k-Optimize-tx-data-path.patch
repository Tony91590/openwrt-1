From 7768f75ce3ccf9e5f7ac1074b24f6f7dd63c5eb7 Mon Sep 17 00:00:00 2001
From: Venkateswara Naralasetty <quic_vnaralas@quicinc.com>
Date: Thu, 18 Nov 2021 13:30:45 +0530
Subject: ath11k: Optimize tx data path.

Adding following optimizations in tx data path to improve
performance in terms of CPU and throughput.

Change-Id: Iee582f19017445a971be1bdf04d81f61899f0eae
Signed-off-by: Venkateswara Naralasetty <quic_vnaralas@quicinc.com>
---
 .../335-0001-ath11k-optimize-tx-completions.patch  | 262 +++++++++++++++++++
 ...11k-use-DECLARE_BITMAP-for-idr-operations.patch | 282 +++++++++++++++++++++
 ...-HAL_TCL_DATA_CMD_INFO2_TID_OVERWRITE-con.patch | 144 +++++++++++
 ...35-0004-ath11k-use-single-TCL-ring-for-tx.patch |  56 ++++
 .../335-0005-mac80211-simple-tx-for-AP-mode.patch  |  74 ++++++
 ...-ath11k-add-simple-tx-handler-for-AP-mode.patch | 197 ++++++++++++++
 6 files changed, 1015 insertions(+)
 create mode 100644 mac80211/patches/335-0001-ath11k-optimize-tx-completions.patch
 create mode 100644 mac80211/patches/335-0002-ath11k-use-DECLARE_BITMAP-for-idr-operations.patch
 create mode 100644 mac80211/patches/335-0003-ath11k-skip-HAL_TCL_DATA_CMD_INFO2_TID_OVERWRITE-con.patch
 create mode 100644 mac80211/patches/335-0004-ath11k-use-single-TCL-ring-for-tx.patch
 create mode 100644 mac80211/patches/335-0005-mac80211-simple-tx-for-AP-mode.patch
 create mode 100644 mac80211/patches/335-0006-ath11k-add-simple-tx-handler-for-AP-mode.patch

--- /dev/null
+++ b/mac80211/patches/335-0001-ath11k-optimize-tx-completions.patch
@@ -0,0 +1,262 @@
+From 34b4e65248e7e1605448b06a006347354990bfba Mon Sep 17 00:00:00 2001
+From: Venkateswara Naralasetty <quic_vnaralas@quicinc.com>
+Date: Thu, 11 Nov 2021 10:30:35 +0530
+Subject: [PATCH] ath11k: optimize tx completions
+
+Process the required fields from tx completion status
+in case of stats disabled.
+
+Signed-off-by: Venkateswara Naralasetty <quic_vnaralas@quicinc.com>
+---
+ drivers/net/wireless/ath/ath11k/dp_tx.c | 114 ++++++++++++++++----------------
+ 1 file changed, 58 insertions(+), 56 deletions(-)
+
+diff --git a/drivers/net/wireless/ath/ath11k/dp_tx.c b/drivers/net/wireless/ath/ath11k/dp_tx.c
+index e13c9a3..a71958f 100644
+--- a/drivers/net/wireless/ath/ath11k/dp_tx.c
++++ b/drivers/net/wireless/ath/ath11k/dp_tx.c
+@@ -529,10 +529,34 @@ static void ath11k_dp_tx_cache_peer_stats(struct ath11k *ar,
+ 	}
+ }
+ 
++static inline void ath11k_dp_tx_status_parse(struct ath11k_base *ab,
++					     struct hal_wbm_release_ring *desc,
++					     struct hal_tx_status *ts)
++{
++	ts->buf_rel_source =
++		FIELD_GET(HAL_WBM_RELEASE_INFO0_REL_SRC_MODULE, desc->info0);
++	ts->status = FIELD_GET(HAL_WBM_RELEASE_INFO0_TQM_RELEASE_REASON,
++			       desc->info0);
++	ts->ppdu_id = FIELD_GET(HAL_WBM_RELEASE_INFO1_TQM_STATUS_NUMBER,
++				desc->info1);
++	ts->try_cnt = FIELD_GET(HAL_WBM_RELEASE_INFO1_TRANSMIT_COUNT,
++				desc->info1);
++	ts->ack_rssi = FIELD_GET(HAL_WBM_RELEASE_INFO2_ACK_FRAME_RSSI,
++				 desc->info2);
++	if (desc->info2 & HAL_WBM_RELEASE_INFO2_FIRST_MSDU)
++		ts->flags |= HAL_TX_STATUS_FLAGS_FIRST_MSDU;
++	ts->peer_id = FIELD_GET(HAL_WBM_RELEASE_INFO3_PEER_ID, desc->info3);
++	ts->tid = FIELD_GET(HAL_WBM_RELEASE_INFO3_TID, desc->info3);
++	if (desc->rate_stats.info0 & HAL_TX_RATE_STATS_INFO0_VALID)
++		ts->rate_stats = desc->rate_stats.info0;
++	else
++		ts->rate_stats = 0;
++}
++
+ static void ath11k_dp_tx_complete_msdu(struct ath11k *ar,
+ 				       struct sk_buff *msdu,
+-				       struct hal_tx_status *ts,
+-				       enum hal_wbm_htt_tx_comp_status wbm_status)
++				       struct hal_wbm_release_ring *tx_status,
++				       enum hal_wbm_rel_src_module buf_rel_source)
+ {
+ 	struct ieee80211_tx_status status = { 0 };
+ 	struct ath11k_base *ab = ar->ab;
+@@ -543,9 +567,12 @@ static void ath11k_dp_tx_complete_msdu(struct ath11k *ar,
+ 	struct ieee80211_vif *vif = NULL;
+ 	struct rate_info rate;
+ 	struct ath11k_vif *arvif = NULL;
++	struct hal_tx_status ts = { 0 };
++	enum hal_wbm_htt_tx_comp_status wbm_status;
++	enum hal_wbm_tqm_rel_reason rel_status;
+ 	u8 flags = 0;
+ 
+-	if (unlikely(WARN_ON_ONCE(ts->buf_rel_source != HAL_WBM_REL_SRC_MODULE_TQM))) {
++	if (unlikely(WARN_ON_ONCE(buf_rel_source != HAL_WBM_REL_SRC_MODULE_TQM))) {
+ 		/* Must not happen */
+ 		return;
+ 	}
+@@ -556,11 +583,14 @@ static void ath11k_dp_tx_complete_msdu(struct ath11k *ar,
+ 
+ 	flags = skb_cb->flags;
+ 
+-	/* Free skb here if stats is disabled */
++	rel_status = FIELD_GET(HAL_WBM_RELEASE_INFO0_TQM_RELEASE_REASON,
++			       tx_status->info0);
++
++ 	/* Free skb here if stats is disabled */
+ 	if (ab->stats_disable && !(flags & ATH11K_SKB_TX_STATUS)) {
+ 		if (msdu->destructor) {
+ 			msdu->wifi_acked_valid = 1;
+-			msdu->wifi_acked = ts->status == HAL_WBM_TQM_REL_REASON_FRAME_ACKED;
++			msdu->wifi_acked = rel_status == HAL_WBM_TQM_REL_REASON_FRAME_ACKED;
+ 		}
+ 		if (skb_has_frag_list(msdu)) {
+ 			kfree_skb_list(skb_shinfo(msdu)->frag_list);
+@@ -570,6 +600,8 @@ static void ath11k_dp_tx_complete_msdu(struct ath11k *ar,
+ 		return;
+ 	}
+ 
++	ath11k_dp_tx_status_parse(ab, tx_status, &ts);
++
+ 	rcu_read_lock();
+ 
+ 	if (unlikely(!rcu_dereference(ab->pdevs_active[ar->pdev_idx]))) {
+@@ -582,6 +614,9 @@ static void ath11k_dp_tx_complete_msdu(struct ath11k *ar,
+ 		goto exit;
+ 	}
+ 
++	wbm_status = FIELD_GET(HTT_TX_WBM_COMP_INFO0_STATUS,
++			       tx_status->info0);
++
+ 	vif = skb_cb->vif;
+ 	arvif = (void *)vif->drv_priv;
+ 	if(arvif && wbm_status < HAL_WBM_REL_HTT_TX_COMP_STATUS_MAX)
+@@ -593,41 +628,41 @@ static void ath11k_dp_tx_complete_msdu(struct ath11k *ar,
+ 	/* skip tx rate update from ieee80211_status*/
+ 	info->status.rates[0].idx = -1;
+ 
+-	if (ts->status == HAL_WBM_TQM_REL_REASON_FRAME_ACKED &&
++	if (ts.status == HAL_WBM_TQM_REL_REASON_FRAME_ACKED &&
+ 	    !(info->flags & IEEE80211_TX_CTL_NO_ACK) &&
+ 	    !(flags & ATH11K_SKB_F_NOACK_TID)) {
+ 		info->flags |= IEEE80211_TX_STAT_ACK;
+ 		info->status.ack_signal = ATH11K_DEFAULT_NOISE_FLOOR +
+-					  ts->ack_rssi;
++					  ts.ack_rssi;
+ 		info->status.is_valid_ack_signal = true;
+ 	}
+ 
+-	if (ts->status == HAL_WBM_TQM_REL_REASON_CMD_REMOVE_TX &&
++	if (ts.status == HAL_WBM_TQM_REL_REASON_CMD_REMOVE_TX &&
+ 	    (info->flags & IEEE80211_TX_CTL_NO_ACK) &&
+ 	    (flags & ATH11K_SKB_F_NOACK_TID))
+ 		info->flags |= IEEE80211_TX_STAT_NOACK_TRANSMITTED;
+ 
+ 	if (unlikely(ath11k_debugfs_is_extd_tx_stats_enabled(ar))) {
+-		if (ts->flags & HAL_TX_STATUS_FLAGS_FIRST_MSDU) {
++		if (ts.flags & HAL_TX_STATUS_FLAGS_FIRST_MSDU) {
+ 			if (ar->last_ppdu_id == 0) {
+-				ar->last_ppdu_id = ts->ppdu_id;
+-			} else if (ar->last_ppdu_id == ts->ppdu_id ||
++				ar->last_ppdu_id = ts.ppdu_id;
++			} else if (ar->last_ppdu_id == ts.ppdu_id ||
+ 				   ar->cached_ppdu_id == ar->last_ppdu_id) {
+ 				ar->cached_ppdu_id = ar->last_ppdu_id;
+ 				ar->cached_stats.is_ampdu = true;
+-				ath11k_debugfs_sta_update_txcompl(ar, msdu, ts);
++				ath11k_debugfs_sta_update_txcompl(ar, msdu, &ts);
+ 				memset(&ar->cached_stats, 0,
+ 				       sizeof(struct ath11k_per_peer_tx_stats));
+ 			} else {
+ 				ar->cached_stats.is_ampdu = false;
+-				ath11k_debugfs_sta_update_txcompl(ar, msdu, ts);
++				ath11k_debugfs_sta_update_txcompl(ar, msdu, &ts);
+ 				memset(&ar->cached_stats, 0,
+ 				       sizeof(struct ath11k_per_peer_tx_stats));
+ 			}
+-			ar->last_ppdu_id = ts->ppdu_id;
++			ar->last_ppdu_id = ts.ppdu_id;
+ 		}
+ 
+-		ath11k_dp_tx_cache_peer_stats(ar, msdu, ts);
++		ath11k_dp_tx_cache_peer_stats(ar, msdu, &ts);
+ 	}
+ 
+ 	/* NOTE: Tx rate status reporting. Tx completion status does not have
+@@ -636,11 +671,11 @@ static void ath11k_dp_tx_complete_msdu(struct ath11k *ar,
+ 	 */
+ 
+ 	spin_lock_bh(&ab->base_lock);
+-	peer = ath11k_peer_find_by_id(ab, ts->peer_id);
++	peer = ath11k_peer_find_by_id(ab, ts.peer_id);
+ 	if (unlikely(!peer || !peer->sta)) {
+ 		ath11k_dbg(ab, ATH11K_DBG_DATA,
+ 			   "dp_tx: failed to find the peer with peer_id %d\n",
+-			    ts->peer_id);
++			    ts.peer_id);
+ 		spin_unlock_bh(&ab->base_lock);
+ 		dev_kfree_skb_any(msdu);
+ 		goto exit;
+@@ -652,7 +687,7 @@ static void ath11k_dp_tx_complete_msdu(struct ath11k *ar,
+ 	rate = arsta->last_txrate;
+ 	status.rate = &rate;
+ 
+-	if (ts->status != HAL_WBM_TQM_REL_REASON_FRAME_ACKED) {
++	if (ts.status != HAL_WBM_TQM_REL_REASON_FRAME_ACKED) {
+ 		arsta->fail_pkts += 1;
+ 		arsta->per_fail_pkts += 1;
+ 		arsta->fail_bytes += msdu->len;
+@@ -682,37 +717,6 @@ exit:
+ 	rcu_read_unlock();
+ }
+ 
+-static inline void ath11k_dp_tx_status_parse(struct ath11k_base *ab,
+-					     struct hal_wbm_release_ring *desc,
+-					     struct hal_tx_status *ts)
+-{
+-	ts->buf_rel_source =
+-		FIELD_GET(HAL_WBM_RELEASE_INFO0_REL_SRC_MODULE, desc->info0);
+-	if (unlikely(ts->buf_rel_source != HAL_WBM_REL_SRC_MODULE_FW &&
+-	    ts->buf_rel_source != HAL_WBM_REL_SRC_MODULE_TQM))
+-		return;
+-
+-	if (unlikely(ts->buf_rel_source == HAL_WBM_REL_SRC_MODULE_FW))
+-		return;
+-
+-	ts->status = FIELD_GET(HAL_WBM_RELEASE_INFO0_TQM_RELEASE_REASON,
+-			       desc->info0);
+-	ts->ppdu_id = FIELD_GET(HAL_WBM_RELEASE_INFO1_TQM_STATUS_NUMBER,
+-				desc->info1);
+-	ts->try_cnt = FIELD_GET(HAL_WBM_RELEASE_INFO1_TRANSMIT_COUNT,
+-				desc->info1);
+-	ts->ack_rssi = FIELD_GET(HAL_WBM_RELEASE_INFO2_ACK_FRAME_RSSI,
+-				 desc->info2);
+-	if (desc->info2 & HAL_WBM_RELEASE_INFO2_FIRST_MSDU)
+-		ts->flags |= HAL_TX_STATUS_FLAGS_FIRST_MSDU;
+-	ts->peer_id = FIELD_GET(HAL_WBM_RELEASE_INFO3_PEER_ID, desc->info3);
+-	ts->tid = FIELD_GET(HAL_WBM_RELEASE_INFO3_TID, desc->info3);
+-	if (desc->rate_stats.info0 & HAL_TX_RATE_STATS_INFO0_VALID)
+-		ts->rate_stats = desc->rate_stats.info0;
+-	else
+-		ts->rate_stats = 0;
+-}
+-
+ static inline bool ath11k_dp_tx_completion_valid(struct hal_wbm_release_ring *desc)
+ {
+ 	struct htt_tx_wbm_completion *status_desc;
+@@ -736,10 +740,9 @@ void ath11k_dp_tx_completion_handler(struct ath11k_base *ab, int ring_id)
+ 	int hal_ring_id = dp->tx_ring[ring_id].tcl_comp_ring.ring_id;
+ 	struct hal_srng *status_ring = &ab->hal.srng_list[hal_ring_id];
+ 	struct sk_buff *msdu;
+-	struct hal_tx_status ts = { 0 };
+ 	struct dp_tx_ring *tx_ring = &dp->tx_ring[ring_id];
+ 	struct hal_wbm_release_ring *tx_status;
+-	enum hal_wbm_htt_tx_comp_status wbm_status;
++	enum hal_wbm_rel_src_module buf_rel_source;
+ 	int valid_entries, count = 0, i = 0;
+ 	u32 *desc;
+ 	u32 msdu_id, desc_id;
+@@ -779,17 +782,16 @@ void ath11k_dp_tx_completion_handler(struct ath11k_base *ab, int ring_id)
+ 
+ 	while (count--) {
+ 		tx_status = &tx_ring->tx_status[i++];
+-		ath11k_dp_tx_status_parse(ab, tx_status, &ts);
+ 
+ 		desc_id = FIELD_GET(BUFFER_ADDR_INFO1_SW_COOKIE,
+ 				    tx_status->buf_addr_info.info1);
+ 		mac_id = FIELD_GET(DP_TX_DESC_ID_MAC_ID, desc_id);
+ 		msdu_id = FIELD_GET(DP_TX_DESC_ID_MSDU_ID, desc_id);
+ 
+-		wbm_status = FIELD_GET(HTT_TX_WBM_COMP_INFO0_STATUS,
+-				       tx_status->info0);
++		buf_rel_source = FIELD_GET(HAL_WBM_RELEASE_INFO0_REL_SRC_MODULE,
++					   tx_status->info0);
+ 
+-		if (unlikely(ts.buf_rel_source == HAL_WBM_REL_SRC_MODULE_FW)) {
++		if (unlikely(buf_rel_source == HAL_WBM_REL_SRC_MODULE_FW)) {
+ 			ath11k_dp_tx_process_htt_tx_complete(ab,
+ 							     (void *)tx_status,
+ 							     mac_id, msdu_id,
+@@ -813,7 +815,7 @@ void ath11k_dp_tx_completion_handler(struct ath11k_base *ab, int ring_id)
+ 		if (atomic_dec_and_test(&ar->dp.num_tx_pending))
+ 			wake_up(&ar->dp.tx_empty_waitq);
+ 
+-		ath11k_dp_tx_complete_msdu(ar, msdu, &ts, wbm_status);
++		ath11k_dp_tx_complete_msdu(ar, msdu, tx_status, buf_rel_source);
+ 	}
+ }
+ 
+-- 
+2.7.4
+
--- /dev/null
+++ b/mac80211/patches/335-0002-ath11k-use-DECLARE_BITMAP-for-idr-operations.patch
@@ -0,0 +1,282 @@
+From 6cd8cb301e431860e71b8d3453846a9ed0efea81 Mon Sep 17 00:00:00 2001
+From: Venkateswara Naralasetty <quic_vnaralas@quicinc.com>
+Date: Thu, 11 Nov 2021 10:38:26 +0530
+Subject: [PATCH] ath11k: use DECLARE_BITMAP for idr operations
+
+Use DECLARE_BITMAP for declaring bit map for idrs. And use APIs
+find_first_zero_bit, set_bit and clear bit instead of idr_alloc
+and idr_destroy.
+
+This helps in improving idle CPU and throughput.
+
+Signed-off-by: Venkateswara Naralasetty <quic_vnaralas@quicinc.com>
+---
+ drivers/net/wireless/ath/ath11k/dp.c    | 34 +++++++++++++-----
+ drivers/net/wireless/ath/ath11k/dp.h    | 10 +++++-
+ drivers/net/wireless/ath/ath11k/dp_tx.c | 61 ++++++++++++++++++---------------
+ 3 files changed, 69 insertions(+), 36 deletions(-)
+
+diff --git a/drivers/net/wireless/ath/ath11k/dp.c b/drivers/net/wireless/ath/ath11k/dp.c
+index c4a4ca3..5a50825 100644
+--- a/drivers/net/wireless/ath/ath11k/dp.c
++++ b/drivers/net/wireless/ath/ath11k/dp.c
+@@ -455,6 +455,8 @@ static void ath11k_dp_srng_common_cleanup(struct ath11k_base *ab)
+ 	for (i = 0; i < DP_TCL_NUM_RING_MAX; i++) {
+ 		ath11k_dp_srng_cleanup(ab, &dp->tx_ring[i].tcl_data_ring);
+ 		ath11k_dp_srng_cleanup(ab, &dp->tx_ring[i].tcl_comp_ring);
++		kfree(dp->tx_ring[i].idr_pool);
++		dp->tx_ring[i].idr_pool = NULL;
+ 	}
+ 	ath11k_dp_srng_cleanup(ab, &dp->reo_reinject_ring);
+ 	ath11k_dp_srng_cleanup(ab, &dp->rx_rel_ring);
+@@ -525,6 +527,14 @@ static int ath11k_dp_srng_common_setup(struct ath11k_base *ab)
+ 		ath11k_dp_shadow_init_timer(ab, &dp->tx_ring_timer[i],
+ 					    ATH11K_SHADOW_DP_TIMER_INTERVAL,
+ 					    dp->tx_ring[i].tcl_data_ring.ring_id);
++
++		dp->tx_ring[i].idr_pool = kcalloc(DP_TX_IDR_SIZE,
++						  sizeof(struct idr_entry), GFP_KERNEL);
++		if (!dp->tx_ring[i].idr_pool) {
++			ath11k_warn(ab, "failed to allocate memory for idr pool ring(%d)\n", i);
++			ret = -ENOMEM;
++			goto err;
++		}
+ 	}
+ 
+ 	ret = ath11k_dp_srng_setup(ab, &dp->reo_reinject_ring, HAL_REO_REINJECT,
+@@ -1129,9 +1139,8 @@ void ath11k_dp_sta_tx_attach(struct ath11k_sta *arsta, int peer_id)
+ 	arsta->tcl_metadata &= ~HTT_TCL_META_DATA_VALID_HTT;
+ }
+ 
+-static int ath11k_dp_tx_pending_cleanup(int buf_id, void *skb, void *ctx)
++static int ath11k_dp_tx_pending_cleanup(struct ath11k_base *ab, void *skb)
+ {
+-	struct ath11k_base *ab = (struct ath11k_base *)ctx;
+ 	struct sk_buff *msdu = skb;
+ 
+ 	dma_unmap_single(ab->dev, ATH11K_SKB_CB(msdu)->paddr, msdu->len,
+@@ -1146,23 +1155,32 @@ void ath11k_dp_free(struct ath11k_base *ab)
+ {
+ 	struct ath11k_dp *dp = &ab->dp;
+ 	size_t size = 0;
+-	int i;
++	int i, j;
+ 
+ 	size = sizeof(struct hal_wbm_release_ring) * DP_TX_COMP_RING_SIZE;
+ 
+ 	ath11k_dp_link_desc_cleanup(ab, dp->link_desc_banks,
+ 				    HAL_WBM_IDLE_LINK, &dp->wbm_idle_ring);
+ 
++	for (i = 0; i < DP_TCL_NUM_RING_MAX; i++) {
++		struct dp_tx_ring *tx_ring = &dp->tx_ring[i];
++		spin_lock_bh(&tx_ring->tx_idr_lock);
++		for(j = 0; j < DP_TX_IDR_SIZE; j++) {
++			if (tx_ring->idr_pool)
++				break;
++
++			if (test_and_clear_bit(j, tx_ring->idrs))
++				ath11k_dp_tx_pending_cleanup(ab, tx_ring->idr_pool[j].buf);
++		}
++
++		spin_unlock_bh(&tx_ring->tx_idr_lock);
++	}
++
+ 	ath11k_dp_srng_common_cleanup(ab);
+ 
+ 	ath11k_dp_reo_cmd_list_cleanup(ab);
+ 
+ 	for (i = 0; i < DP_TCL_NUM_RING_MAX; i++) {
+-		spin_lock_bh(&dp->tx_ring[i].tx_idr_lock);
+-		idr_for_each(&dp->tx_ring[i].txbuf_idr,
+-			     ath11k_dp_tx_pending_cleanup, ab);
+-		idr_destroy(&dp->tx_ring[i].txbuf_idr);
+-		spin_unlock_bh(&dp->tx_ring[i].tx_idr_lock);
+ 		ATH11K_MEMORY_STATS_DEC(ab, malloc_size, size);
+ 		kfree(dp->tx_ring[i].tx_status);
+ 	}
+diff --git a/drivers/net/wireless/ath/ath11k/dp.h b/drivers/net/wireless/ath/ath11k/dp.h
+index ada1ca6..2b67eb0 100644
+--- a/drivers/net/wireless/ath/ath11k/dp.h
++++ b/drivers/net/wireless/ath/ath11k/dp.h
+@@ -80,6 +80,13 @@ struct dp_rxdma_ring {
+ 
+ #define ATH11K_TX_COMPL_NEXT(x)	(((x) + 1) % DP_TX_COMP_RING_SIZE)
+ 
++struct idr_entry {
++	u32 id;
++	void *buf;
++};
++
++#define DP_TX_IDR_SIZE	4096
++
+ struct dp_tx_ring {
+ 	u8 tcl_data_ring_id;
+ 	struct dp_srng tcl_data_ring;
+@@ -90,6 +97,8 @@ struct dp_tx_ring {
+ 	struct hal_wbm_release_ring *tx_status;
+ 	int tx_status_head;
+ 	int tx_status_tail;
++	DECLARE_BITMAP(idrs, DP_TX_IDR_SIZE);
++	struct idr_entry *idr_pool;
+ };
+ 
+ enum dp_mon_reap_status {
+@@ -215,7 +224,6 @@ struct ath11k_pdev_dp {
+ #define DP_WBM_RELEASE_RING_SIZE	64
+ #define DP_TCL_DATA_RING_SIZE		512
+ #define DP_TX_COMP_RING_SIZE		ATH11K_DP_TX_COMP_RING_SIZE
+-#define DP_TX_IDR_SIZE			DP_TX_COMP_RING_SIZE
+ #define DP_TX_COMP_MAX_ALLOWED		DP_TX_COMP_RING_SIZE
+ #define DP_TCL_CMD_RING_SIZE		32
+ #define DP_TCL_STATUS_RING_SIZE		32
+diff --git a/drivers/net/wireless/ath/ath11k/dp_tx.c b/drivers/net/wireless/ath/ath11k/dp_tx.c
+index a71958f..5955ee7 100644
+--- a/drivers/net/wireless/ath/ath11k/dp_tx.c
++++ b/drivers/net/wireless/ath/ath11k/dp_tx.c
+@@ -123,6 +123,7 @@ int ath11k_dp_tx(struct ath11k *ar, struct ath11k_vif *arvif,
+ 	u8 ring_selector = 0, ring_map = 0;
+ 	bool tcl_ring_retry, is_diff_encap = false;
+ 	u8 align_pad, htt_meta_size = 0, max_tx_ring, tcl_ring_id, ring_id;
++	u32 idr;
+ 
+ 	if (unlikely(test_bit(ATH11K_FLAG_CRASH_FLUSH, &ar->ab->dev_flags)))
+ 		return -ESHUTDOWN;
+@@ -167,23 +168,27 @@ tcl_ring_sel:
+ 	tx_ring = &dp->tx_ring[tcl_ring_id];
+ 
+ 	spin_lock_bh(&tx_ring->tx_idr_lock);
+-	ret = idr_alloc(&tx_ring->txbuf_idr, skb, 0,
+-			DP_TX_IDR_SIZE - 1, GFP_ATOMIC);
+-	spin_unlock_bh(&tx_ring->tx_idr_lock);
+-
+-	if (unlikely(ret < 0)) {
++	idr = find_first_zero_bit(tx_ring->idrs, DP_TX_IDR_SIZE);
++	if (unlikely(idr >= DP_TX_IDR_SIZE)) {
+ 		if (unlikely(ring_map == (BIT(max_tx_ring) - 1))) {
++			spin_unlock_bh(&tx_ring->tx_idr_lock);
+ 			ab->soc_stats.tx_err.idr_na[tcl_ring_id]++;
+ 			return -ENOSPC;
+ 		}
+ 
+ 		/* Check if the next ring is available */
++		spin_unlock_bh(&tx_ring->tx_idr_lock);
+ 		ring_selector++;
+ 		goto tcl_ring_sel;
+ 	}
+ 
++	set_bit(idr, tx_ring->idrs);
++	tx_ring->idr_pool[idr].id = idr;
++	tx_ring->idr_pool[idr].buf = skb;
++	spin_unlock_bh(&tx_ring->tx_idr_lock);
++
+ 	ti.desc_id = FIELD_PREP(DP_TX_DESC_ID_MAC_ID, ar->pdev_idx) |
+-		     FIELD_PREP(DP_TX_DESC_ID_MSDU_ID, ret) |
++		     FIELD_PREP(DP_TX_DESC_ID_MSDU_ID, idr) |
+ 		     FIELD_PREP(DP_TX_DESC_ID_POOL_ID, pool_id);
+ 	ti.encap_type = ath11k_dp_tx_get_encap_type(arvif, skb);
+ 
+@@ -359,10 +364,8 @@ fail_unmap_dma:
+ fail_remove_idr:
+ 	if (ti.pkt_offset)
+ 		skb_pull(skb, ti.pkt_offset);
+-	spin_lock_bh(&tx_ring->tx_idr_lock);
+-	idr_remove(&tx_ring->txbuf_idr,
+-		   FIELD_GET(DP_TX_DESC_ID_MSDU_ID, ti.desc_id));
+-	spin_unlock_bh(&tx_ring->tx_idr_lock);
++
++	clear_bit(idr, tx_ring->idrs);
+ 
+ 	if (tcl_ring_retry)
+ 		goto tcl_ring_sel;
+@@ -375,10 +378,15 @@ static void ath11k_dp_tx_free_txbuf(struct ath11k_base *ab, u8 mac_id,
+ 				    struct dp_tx_ring *tx_ring)
+ {
+ 	struct ath11k *ar;
+-	struct sk_buff *msdu;
++	struct sk_buff *msdu = NULL;
+ 	struct ath11k_skb_cb *skb_cb;
+ 
+-	msdu = idr_find(&tx_ring->txbuf_idr, msdu_id);
++	if (msdu_id < DP_TX_IDR_SIZE &&
++	    tx_ring->idr_pool[msdu_id].id == msdu_id) {
++		msdu = tx_ring->idr_pool[msdu_id].buf;
++		clear_bit(msdu_id, tx_ring->idrs);
++	}
++
+ 	if (!msdu) {
+ 		ath11k_warn(ab, "tx completion for unknown msdu_id %d\n",
+ 			    msdu_id);
+@@ -387,10 +395,6 @@ static void ath11k_dp_tx_free_txbuf(struct ath11k_base *ab, u8 mac_id,
+ 
+ 	skb_cb = ATH11K_SKB_CB(msdu);
+ 
+-	spin_lock(&tx_ring->tx_idr_lock);
+-	idr_remove(&tx_ring->txbuf_idr, msdu_id);
+-	spin_unlock(&tx_ring->tx_idr_lock);
+-
+ 	dma_unmap_single(ab->dev, skb_cb->paddr, msdu->len, DMA_TO_DEVICE);
+ 	dev_kfree_skb_any(msdu);
+ 
+@@ -410,8 +414,14 @@ ath11k_dp_tx_htt_tx_complete_buf(struct ath11k_base *ab,
+ 	struct ath11k *ar;
+ 	struct ieee80211_vif *vif;
+ 	u8 flags = 0;
++	u32 msdu_id = ts->msdu_id;
++
++	if (msdu_id < DP_TX_IDR_SIZE &&
++	    tx_ring->idr_pool[msdu_id].id == msdu_id) {
++		msdu = tx_ring->idr_pool[msdu_id].buf;
++		clear_bit(msdu_id, tx_ring->idrs);
++	}
+ 
+-	msdu = idr_find(&tx_ring->txbuf_idr, ts->msdu_id);
+ 	if (unlikely(!msdu)) {
+ 		ath11k_warn(ab, "htt tx completion for unknown msdu_id %d\n",
+ 			    ts->msdu_id);
+@@ -423,10 +433,6 @@ ath11k_dp_tx_htt_tx_complete_buf(struct ath11k_base *ab,
+ 
+ 	ar = skb_cb->ar;
+ 
+-	spin_lock(&tx_ring->tx_idr_lock);
+-	idr_remove(&tx_ring->txbuf_idr, ts->msdu_id);
+-	spin_unlock(&tx_ring->tx_idr_lock);
+-
+ 	if (atomic_dec_and_test(&ar->dp.num_tx_pending))
+ 		wake_up(&ar->dp.tx_empty_waitq);
+ 
+@@ -739,7 +745,7 @@ void ath11k_dp_tx_completion_handler(struct ath11k_base *ab, int ring_id)
+ 	struct ath11k_dp *dp = &ab->dp;
+ 	int hal_ring_id = dp->tx_ring[ring_id].tcl_comp_ring.ring_id;
+ 	struct hal_srng *status_ring = &ab->hal.srng_list[hal_ring_id];
+-	struct sk_buff *msdu;
++	struct sk_buff *msdu = NULL;
+ 	struct dp_tx_ring *tx_ring = &dp->tx_ring[ring_id];
+ 	struct hal_wbm_release_ring *tx_status;
+ 	enum hal_wbm_rel_src_module buf_rel_source;
+@@ -799,17 +805,18 @@ void ath11k_dp_tx_completion_handler(struct ath11k_base *ab, int ring_id)
+ 			continue;
+ 		}
+ 
+-		msdu = idr_find(&tx_ring->txbuf_idr, msdu_id);
++		if (msdu_id < DP_TX_IDR_SIZE &&
++		    tx_ring->idr_pool[msdu_id].id == msdu_id) {
++			msdu = tx_ring->idr_pool[msdu_id].buf;
++			clear_bit(msdu_id, tx_ring->idrs);
++		}
++
+ 		if (unlikely(!msdu)) {
+ 			ath11k_warn(ab, "tx completion for unknown msdu_id %d\n",
+ 				    msdu_id);
+ 			continue;
+ 		}
+ 
+-		spin_lock(&tx_ring->tx_idr_lock);
+-		idr_remove(&tx_ring->txbuf_idr, msdu_id);
+-		spin_unlock(&tx_ring->tx_idr_lock);
+-
+ 		ar = ab->pdevs[mac_id].ar;
+ 
+ 		if (atomic_dec_and_test(&ar->dp.num_tx_pending))
+-- 
+2.7.4
+
--- /dev/null
+++ b/mac80211/patches/335-0003-ath11k-skip-HAL_TCL_DATA_CMD_INFO2_TID_OVERWRITE-con.patch
@@ -0,0 +1,144 @@
+From c7bd857a315fb299e4c984be2f3720428477ae6e Mon Sep 17 00:00:00 2001
+From: Venkateswara Naralasetty <quic_vnaralas@quicinc.com>
+Date: Thu, 11 Nov 2021 11:14:08 +0530
+Subject: [PATCH] ath11k: skip HAL_TCL_DATA_CMD_INFO2_TID_OVERWRITE config
+
+Don't set HAL_TCL_DATA_CMD_INFO2_TID_OVERWRITE flag to TCL,
+HW only take care of tid classification if this flag is not set.
+
+Signed-off-by: Venkateswara Naralasetty <quic_vnaralas@quicinc.com>
+---
+ drivers/net/wireless/ath/ath11k/dp_tx.c  | 19 +------------------
+ drivers/net/wireless/ath/ath11k/hal_tx.c |  1 -
+ drivers/net/wireless/ath/ath11k/mac.c    |  2 ++
+ include/net/mac80211.h                   |  3 +++
+ net/mac80211/debugfs.c                   |  1 +
+ net/mac80211/wme.c                       |  3 +++
+ 6 files changed, 10 insertions(+), 19 deletions(-)
+
+diff --git a/drivers/net/wireless/ath/ath11k/dp_tx.c b/drivers/net/wireless/ath/ath11k/dp_tx.c
+index 5955ee7..ef51d62 100644
+--- a/drivers/net/wireless/ath/ath11k/dp_tx.c
++++ b/drivers/net/wireless/ath/ath11k/dp_tx.c
+@@ -42,19 +42,6 @@ static void ath11k_dp_tx_encap_nwifi(struct sk_buff *skb)
+ 	hdr->frame_control &= ~__cpu_to_le16(IEEE80211_STYPE_QOS_DATA);
+ }
+ 
+-static u8 ath11k_dp_tx_get_tid(struct sk_buff *skb)
+-{
+-	struct ieee80211_hdr *hdr = (void *)skb->data;
+-	struct ath11k_skb_cb *cb = ATH11K_SKB_CB(skb);
+-
+-	if (cb->flags & ATH11K_SKB_HW_80211_ENCAP)
+-		return skb->priority & IEEE80211_QOS_CTL_TID_MASK;
+-	else if (!ieee80211_is_data_qos(hdr->frame_control))
+-		return HAL_DESC_REO_NON_QOS_TID;
+-	else
+-		return skb->priority & IEEE80211_QOS_CTL_TID_MASK;
+-}
+-
+ enum hal_encrypt_type ath11k_dp_tx_get_encrypt_type(u32 cipher)
+ {
+ 	switch (cipher) {
+@@ -133,7 +120,6 @@ int ath11k_dp_tx(struct ath11k *ar, struct ath11k_vif *arvif,
+ 		return -ENOTSUPP;
+ 
+ 	max_tx_ring = ab->hw_params.max_tx_ring;
+-	pool_id = skb_get_queue_mapping(skb) & (ATH11K_HW_MAX_QUEUES - 1);
+ 
+ 	/* Let the default ring selection be based on current processor
+ 	 * number, where one of the 3 tcl rings are selected based on
+@@ -149,6 +135,7 @@ int ath11k_dp_tx(struct ath11k *ar, struct ath11k_vif *arvif,
+  	}
+ #endif
+ 	ring_selector = smp_processor_id();
++	pool_id = ring_selector;
+ 
+ tcl_ring_sel:
+ 	tcl_ring_retry = false;
+@@ -234,10 +221,6 @@ tcl_ring_sel:
+ 	if (ieee80211_vif_is_mesh(arvif->vif))
+ 		ti.enable_mesh = true;
+ 
+-	ti.flags1 |= FIELD_PREP(HAL_TCL_DATA_CMD_INFO2_TID_OVERWRITE, 1);
+-
+-	ti.tid = ath11k_dp_tx_get_tid(skb);
+-
+ 	switch (ti.encap_type) {
+ 	case HAL_TCL_ENCAP_TYPE_NATIVE_WIFI:
+ 		if (arvif->vif->offload_flags & IEEE80211_OFFLOAD_ENCAP_ENABLED)
+diff --git a/drivers/net/wireless/ath/ath11k/hal_tx.c b/drivers/net/wireless/ath/ath11k/hal_tx.c
+index d3fa937..0c5f03c 100644
+--- a/drivers/net/wireless/ath/ath11k/hal_tx.c
++++ b/drivers/net/wireless/ath/ath11k/hal_tx.c
+@@ -64,7 +64,6 @@ void ath11k_hal_tx_cmd_desc_setup(struct ath11k_base *ab, void *cmd,
+ 		FIELD_PREP(HAL_TCL_DATA_CMD_INFO1_PKT_OFFSET, ti->pkt_offset);
+ 
+ 	tcl_cmd.info2 = ti->flags1 |
+-		FIELD_PREP(HAL_TCL_DATA_CMD_INFO2_TID, ti->tid) |
+ 		FIELD_PREP(HAL_TCL_DATA_CMD_INFO2_LMAC_ID, ti->lmac_id);
+ 
+ 	tcl_cmd.info3 = FIELD_PREP(HAL_TCL_DATA_CMD_INFO3_DSCP_TID_TABLE_IDX,
+diff --git a/drivers/net/wireless/ath/ath11k/mac.c b/drivers/net/wireless/ath/ath11k/mac.c
+index 7316452..6942ebb 100644
+--- a/drivers/net/wireless/ath/ath11k/mac.c
++++ b/drivers/net/wireless/ath/ath11k/mac.c
+@@ -11049,6 +11049,8 @@ static int __ath11k_mac_register(struct ath11k *ar)
+ 			ieee80211_hw_set(ar->hw, USES_RSS);
+ 	}
+ 
++	ieee80211_hw_set(ar->hw, SUPPORTS_TID_CLASS_OFFLOAD);
++
+ 	/* If supported number of NSS is less than the maximum
+ 	 * NSS of device, then SUPPORTS_VHT_EXT_NSS_BW capablity
+ 	 * needs to adevertise to upper layer
+diff --git a/include/net/mac80211.h b/include/net/mac80211.h
+index 002354c..633e723 100644
+--- a/include/net/mac80211.h
++++ b/include/net/mac80211.h
+@@ -2502,6 +2502,8 @@ struct ieee80211_txq {
+  *
+  * @IEEE80211_HW_SUPPORTS_MULTI_BSSID_AP: Hardware supports multi BSSID in AP mode
+  *
++ * @IEEE80211_HW_SUPPORTS_TID_CLASS_OFFLOAD: Hardware suports tid calssification offload.
++ *
+  * @NUM_IEEE80211_HW_FLAGS: number of hardware flags, used for sizing arrays
+  */
+ enum ieee80211_hw_flags {
+@@ -2560,6 +2562,7 @@ enum ieee80211_hw_flags {
+ 	IEEE80211_HW_SUPPORTS_NSS_OFFLOAD,
+ 	IEEE80211_HW_SUPPORTS_MULTI_BSSID_AP,
+ 	IEEE80211_HW_SUPPORTS_MESH_NSS_OFFLOAD,
++	IEEE80211_HW_SUPPORTS_TID_CLASS_OFFLOAD,
+ 
+ 	/* keep last, obviously */
+ 	NUM_IEEE80211_HW_FLAGS
+diff --git a/net/mac80211/debugfs.c b/net/mac80211/debugfs.c
+index 87dd864..56ace66 100644
+--- a/net/mac80211/debugfs.c
++++ b/net/mac80211/debugfs.c
+@@ -447,6 +447,7 @@ static const char *hw_flag_names[] = {
+ 	FLAG(SUPPORTS_NSS_OFFLOAD),
+ 	FLAG(SUPPORTS_MULTI_BSSID_AP),
+ 	FLAG(SUPPORTS_MESH_NSS_OFFLOAD),
++	FLAG(SUPPORTS_TID_CLASS_OFFLOAD),
+ #undef FLAG
+ };
+ 
+diff --git a/net/mac80211/wme.c b/net/mac80211/wme.c
+index 9ea6004..c388bd8 100644
+--- a/net/mac80211/wme.c
++++ b/net/mac80211/wme.c
+@@ -186,6 +186,9 @@ u16 ieee80211_select_queue(struct ieee80211_sub_if_data *sdata,
+ 	const u8 *ra = NULL;
+ 	u16 ret;
+ 
++	if (ieee80211_hw_check(&local->hw, SUPPORTS_TID_CLASS_OFFLOAD))
++		return 0;
++
+ 	/* when using iTXQ, we can do this later */
+ 	if (local->ops->wake_tx_queue)
+ 		return 0;
+-- 
+2.7.4
+
--- /dev/null
+++ b/mac80211/patches/335-0004-ath11k-use-single-TCL-ring-for-tx.patch
@@ -0,0 +1,56 @@
+From e43739707804e9800c16e88af8e2087da82f4542 Mon Sep 17 00:00:00 2001
+From: Venkateswara Naralasetty <quic_vnaralas@quicinc.com>
+Date: Thu, 11 Nov 2021 12:02:27 +0530
+Subject: [PATCH] ath11k: use single TCL ring for tx
+
+Using single TCL ring is enough to achieve peak throughput
+for QCN6122 and IPQ5018.
+
+Signed-off-by: Venkateswara Naralasetty <quic_vnaralas@quicinc.com>
+---
+ drivers/net/wireless/ath/ath11k/core.c | 8 ++++----
+ 1 file changed, 4 insertions(+), 4 deletions(-)
+
+diff --git a/drivers/net/wireless/ath/ath11k/core.c b/drivers/net/wireless/ath/ath11k/core.c
+index f2f2e5c..46150df 100644
+--- a/drivers/net/wireless/ath/ath11k/core.c
++++ b/drivers/net/wireless/ath/ath11k/core.c
+@@ -349,7 +349,7 @@ static const struct ath11k_hw_params ath11k_hw_params[] = {
+ 		.rx_mac_buf_ring = false,
+ 		.vdev_start_delay = false,
+ 		.htt_peer_map_v2 = true,
+-		.tcl_0_only = false,
++		.tcl_0_only = true,
+ 		.spectral_max_fft_bins = 1024,
+ 		.spectral_summary_pad_sz = 16,
+ 		.spectral_fft_hdr_len = 24,
+@@ -359,7 +359,7 @@ static const struct ath11k_hw_params ath11k_hw_params[] = {
+ 		.fwmem_mode_change = false,
+ 		.cold_boot_calib = true,
+ 		.is_qdss_support = false,
+-		.max_tx_ring = DP_TCL_NUM_RING_MAX,
++		.max_tx_ring = 1,
+ 		.wakeup_mhi = false,
+ 		.reo_status_poll = true,
+ 		.num_vdevs_peers = ath11k_vdevs_peers_ipq5018,
+@@ -413,7 +413,7 @@ static const struct ath11k_hw_params ath11k_hw_params[] = {
+ 		.rx_mac_buf_ring = false,
+ 		.vdev_start_delay = false,
+ 		.htt_peer_map_v2 = true,
+-		.tcl_0_only = false,
++		.tcl_0_only = true,
+ 		.spectral_max_fft_bins = 1024,
+ 		.spectral_summary_pad_sz = 16,
+ 		.spectral_fft_hdr_len = 24,
+@@ -423,7 +423,7 @@ static const struct ath11k_hw_params ath11k_hw_params[] = {
+ 		.cold_boot_calib = true,
+  		.fwmem_mode_change = false,
+  		.is_qdss_support = true,
+-		.max_tx_ring = DP_TCL_NUM_RING_MAX,
++		.max_tx_ring = 1,
+ 		.wakeup_mhi = false,
+ 		.reo_status_poll = true,
+ 		.num_vdevs_peers = ath11k_vdevs_peers_ipq5018,
+-- 
+2.7.4
+
--- /dev/null
+++ b/mac80211/patches/335-0005-mac80211-simple-tx-for-AP-mode.patch
@@ -0,0 +1,74 @@
+From 190652ce1b56a41ed3a99d9f9c9160deba34810b Mon Sep 17 00:00:00 2001
+From: Venkateswara Naralasetty <quic_vnaralas@quicinc.com>
+Date: Thu, 18 Nov 2021 12:28:31 +0530
+Subject: [PATCH] mac80211: simple tx for AP mode
+
+Introduced new API ieee80211_8023_xmit_ap to make tx simple and
+to avoid unnecessary checks for AP mode.
+
+Signed-off-by: Venkateswara Naralasetty <quic_vnaralas@quicinc.com>
+---
+ net/mac80211/tx.c | 40 ++++++++++++++++++++++++++++++++++++++++
+ 1 file changed, 40 insertions(+)
+
+diff --git a/net/mac80211/tx.c b/net/mac80211/tx.c
+index 8a4f3bd..df65e1e 100644
+--- a/net/mac80211/tx.c
++++ b/net/mac80211/tx.c
+@@ -4360,6 +4360,41 @@ out_free:
+ 	kfree_skb(skb);
+ }
+ 
++void ieee80211_8023_xmit_ap(struct ieee80211_sub_if_data *sdata,
++			    struct net_device *dev, struct sta_info *sta,
++			    struct ieee80211_key *key, struct sk_buff *skb)
++{
++	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
++	struct ethhdr *ehdr = (struct ethhdr *)skb->data;
++	struct ieee80211_local *local = sdata->local;
++	struct ieee80211_sta *pubsta = NULL;
++	struct ieee80211_tx_control control = {};
++	unsigned char *ra = ehdr->h_dest;
++	bool multicast;
++
++	multicast = is_multicast_ether_addr(ra);
++
++	memset(info, 0, sizeof(*info));
++
++	if (unlikely(skb->sk &&
++		     skb_shinfo(skb)->tx_flags & SKBTX_WIFI_STATUS))
++		info->ack_frame_id = ieee80211_store_ack_skb(local, skb,
++							     &info->flags, NULL);
++
++	info->flags |= IEEE80211_TX_CTL_HW_80211_ENCAP;
++	info->control.vif = &sdata->vif;
++
++	if (key)
++		info->control.hw_key = &key->conf;
++
++	if (sta && sta->uploaded)
++		pubsta = &sta->sta;
++
++	control.sta = pubsta;
++
++	drv_tx(local, &control, skb);
++}
++
+ netdev_tx_t ieee80211_subif_start_xmit_8023(struct sk_buff *skb,
+ 					    struct net_device *dev)
+ {
+@@ -4399,6 +4434,11 @@ netdev_tx_t ieee80211_subif_start_xmit_8023(struct sk_buff *skb,
+ 	if (key && (!(key->flags & KEY_FLAG_UPLOADED_TO_HARDWARE)))
+ 		goto skip_offload;
+ 
++	if (sdata->vif.type == NL80211_IFTYPE_AP) {
++		ieee80211_8023_xmit_ap(sdata, dev, sta, key, skb);
++		goto out;
++	}
++
+ tx_offload:
+ 	ieee80211_8023_xmit(sdata, dev, sta, key, skb);
+ 	goto out;
+-- 
+2.7.4
+
--- /dev/null
+++ b/mac80211/patches/335-0006-ath11k-add-simple-tx-handler-for-AP-mode.patch
@@ -0,0 +1,197 @@
+From 9600bc899bd28386375f5b5902a33f1984ce9da8 Mon Sep 17 00:00:00 2001
+From: Venkateswara Naralasetty <quic_vnaralas@quicinc.com>
+Date: Thu, 18 Nov 2021 13:11:02 +0530
+Subject: [PATCH] ath11k: add simple tx handler for AP mode
+
+Add simple tx handler for AP mode to skip cheks which are not
+applicable for AP mode.
+
+Signed-off-by: Venkateswara Naralasetty <quic_vnaralas@quicinc.com>
+---
+ drivers/net/wireless/ath/ath11k/dp_tx.c    | 123 +++++++++++++++++++++++++++++
+ drivers/net/wireless/ath/ath11k/dp_tx.h    |   2 +
+ drivers/net/wireless/ath/ath11k/hal_desc.h |   6 ++
+ drivers/net/wireless/ath/ath11k/mac.c      |   3 +
+ 4 files changed, 134 insertions(+)
+
+diff --git a/drivers/net/wireless/ath/ath11k/dp_tx.c b/drivers/net/wireless/ath/ath11k/dp_tx.c
+index ef51d62..34a56bb 100644
+--- a/drivers/net/wireless/ath/ath11k/dp_tx.c
++++ b/drivers/net/wireless/ath/ath11k/dp_tx.c
+@@ -92,6 +92,129 @@ static int ath11k_dp_prepare_htt_metadata(struct sk_buff *skb,
+ 	return 0;
+ }
+ 
++int ath11k_dp_tx_simple(struct ath11k *ar, struct ath11k_vif *arvif,
++			struct sk_buff *skb, struct ath11k_sta *arsta)
++{
++	struct ath11k_base *ab = ar->ab;
++	struct ath11k_dp *dp = &ab->dp;
++	struct ath11k_skb_cb *skb_cb = ATH11K_SKB_CB(skb);
++	struct hal_srng *tcl_ring;
++	struct dp_tx_ring *tx_ring;
++	struct hal_tcl_data_cmd *tcl_desc;
++	void *hal_tcl_desc;
++	dma_addr_t paddr;
++	u8 pool_id;
++	u8 hal_ring_id;
++	int ret;
++	u32 idr;
++	u8 tcl_ring_id, ring_id, max_tx_ring;
++	u8 buf_id;
++	u32 desc_id;
++	u8 ring_selector;
++
++	max_tx_ring = ab->hw_params.max_tx_ring;
++
++	if (unlikely(atomic_read(&ab->num_max_allowed) > DP_TX_COMP_MAX_ALLOWED)) {
++		atomic_inc(&ab->soc_stats.tx_err.max_fail);
++		ret = -EINVAL;
++	}
++
++	ring_selector = smp_processor_id();
++	pool_id = ring_selector;
++
++	if (ar->ab->hw_params.tcl_0_only) {
++		ring_id = 0;
++		tcl_ring_id = 0;
++	} else {
++		ring_id = ring_selector % max_tx_ring;
++		tcl_ring_id = (ring_id == DP_TCL_NUM_RING_MAX) ?
++			      DP_TCL_NUM_RING_MAX - 1 : ring_id;
++	}
++
++	buf_id = tcl_ring_id + HAL_RX_BUF_RBM_SW0_BM;
++	tx_ring = &dp->tx_ring[tcl_ring_id];
++
++	spin_lock_bh(&tx_ring->tx_idr_lock);
++	idr = find_first_zero_bit(tx_ring->idrs, DP_TX_IDR_SIZE);
++	if (unlikely(idr >= DP_TX_IDR_SIZE)) {
++		spin_unlock_bh(&tx_ring->tx_idr_lock);
++		return -ENOSPC;
++	}
++
++	set_bit(idr, tx_ring->idrs);
++	tx_ring->idr_pool[idr].id = idr;
++	tx_ring->idr_pool[idr].buf = skb;
++	spin_unlock_bh(&tx_ring->tx_idr_lock);
++
++	desc_id = FIELD_PREP(DP_TX_DESC_ID_MAC_ID, ar->pdev_idx) |
++		  FIELD_PREP(DP_TX_DESC_ID_MSDU_ID, idr) |
++		  FIELD_PREP(DP_TX_DESC_ID_POOL_ID, pool_id);
++
++	skb_cb->vif = arvif->vif;
++	skb_cb->ar = ar;
++
++	paddr = dma_map_single(ab->dev, skb->data, skb->len, DMA_TO_DEVICE);
++	if (unlikely(dma_mapping_error(ab->dev, paddr))) {
++		atomic_inc(&ab->soc_stats.tx_err.misc_fail);
++		ath11k_warn(ab, "failed to DMA map data Tx buffer\n");
++		ret = -ENOMEM;
++		goto fail_remove_idr;
++	}
++
++	skb_cb->paddr = paddr;
++
++	hal_ring_id = tx_ring->tcl_data_ring.ring_id;
++	tcl_ring = &ab->hal.srng_list[hal_ring_id];
++
++	spin_lock_bh(&tcl_ring->lock);
++	ath11k_hal_srng_access_begin(ab, tcl_ring);
++
++	hal_tcl_desc = (void *)ath11k_hal_srng_src_get_next_entry(ab, tcl_ring);
++	if (unlikely(!hal_tcl_desc)) {
++		ath11k_hal_srng_access_end(ab, tcl_ring);
++		spin_unlock_bh(&tcl_ring->lock);
++		ab->soc_stats.tx_err.desc_na[tcl_ring_id]++;
++		ret = -ENOMEM;
++		goto fail_remove_idr;
++	}
++
++	tcl_desc = (struct hal_tcl_data_cmd *)(hal_tcl_desc + sizeof(struct hal_tlv_hdr));
++	tcl_desc->info3 = 0;
++	tcl_desc->info4 = 0;
++
++	tcl_desc->buf_addr_info.info0 = FIELD_PREP(BUFFER_ADDR_INFO0_ADDR, paddr);
++	tcl_desc->buf_addr_info.info1 = FIELD_PREP(BUFFER_ADDR_INFO1_ADDR,
++			((uint64_t)paddr >> HAL_ADDR_MSB_REG_SHIFT));
++	tcl_desc->buf_addr_info.info1 |= FIELD_PREP(BUFFER_ADDR_INFO1_RET_BUF_MGR, buf_id) |
++		FIELD_PREP(BUFFER_ADDR_INFO1_SW_COOKIE, desc_id);
++	tcl_desc->info0 = FIELD_PREP(HAL_TCL_DATA_CMD_INFO0_SEARCH_TYPE,
++			arvif->search_type) |
++		FIELD_PREP(HAL_TCL_DATA_CMD_INFO0_ENCAP_TYPE, HAL_TCL_ENCAP_TYPE_ETHERNET) |
++		FIELD_PREP(HAL_TCL_DATA_CMD_INFO0_ADDR_EN, arvif->hal_addr_search_flags) |
++		FIELD_PREP(HAL_TCL_DATA_CMD_INFO0_CMD_NUM, arvif->tcl_metadata);
++
++	tcl_desc->info1 = FIELD_PREP(HAL_TCL_DATA_CMD_INFO1_DATA_LEN, skb->len);
++
++	if (likely(skb->ip_summed == CHECKSUM_PARTIAL))
++		tcl_desc->info1 |= TX_IP_CHECKSUM;
++
++	tcl_desc->info2 = FIELD_PREP(HAL_TCL_DATA_CMD_INFO2_LMAC_ID, ar->lmac_id);
++
++	dmac_clean_range((void *)tcl_desc, (void *)(((u8 *)tcl_desc) + 32));
++
++	ath11k_hal_srng_access_end(ab, tcl_ring);
++	spin_unlock_bh(&tcl_ring->lock);
++
++	atomic_inc(&ar->dp.num_tx_pending);
++	atomic_inc(&ab->num_max_allowed);
++
++	return 0;
++
++fail_remove_idr:
++	clear_bit(idr, tx_ring->idrs);
++	return ret;
++}
++
+ int ath11k_dp_tx(struct ath11k *ar, struct ath11k_vif *arvif,
+ 		 struct sk_buff *skb, struct ath11k_sta *arsta)
+ {
+diff --git a/drivers/net/wireless/ath/ath11k/dp_tx.h b/drivers/net/wireless/ath/ath11k/dp_tx.h
+index 28e7b35..bed42c2 100644
+--- a/drivers/net/wireless/ath/ath11k/dp_tx.h
++++ b/drivers/net/wireless/ath/ath11k/dp_tx.h
+@@ -220,6 +220,8 @@ struct htt_tx_msdu_desc_ext {
+ int ath11k_dp_tx_htt_h2t_ver_req_msg(struct ath11k_base *ab);
+ int ath11k_dp_tx(struct ath11k *ar, struct ath11k_vif *arvif,
+ 		 struct sk_buff *skb, struct ath11k_sta *arsta);
++int ath11k_dp_tx_simple(struct ath11k *ar, struct ath11k_vif *arvif,
++			struct sk_buff *skb, struct ath11k_sta *arsta);
+ void ath11k_dp_tx_completion_handler(struct ath11k_base *ab, int ring_id);
+ int ath11k_dp_tx_send_reo_cmd(struct ath11k_base *ab, struct dp_rx_tid *rx_tid,
+ 			      enum hal_reo_cmd_type type,
+diff --git a/drivers/net/wireless/ath/ath11k/hal_desc.h b/drivers/net/wireless/ath/ath11k/hal_desc.h
+index 2b76374..bd25b0f 100644
+--- a/drivers/net/wireless/ath/ath11k/hal_desc.h
++++ b/drivers/net/wireless/ath/ath11k/hal_desc.h
+@@ -952,6 +952,12 @@ struct hal_reo_flush_cache {
+ 	u32 rsvd0[6];
+ } __packed;
+ 
++#define TX_IP_CHECKSUM HAL_TCL_DATA_CMD_INFO1_IP4_CKSUM_EN | \
++		       HAL_TCL_DATA_CMD_INFO1_UDP4_CKSUM_EN | \
++		       HAL_TCL_DATA_CMD_INFO1_UDP6_CKSUM_EN | \
++		       HAL_TCL_DATA_CMD_INFO1_TCP4_CKSUM_EN | \
++		       HAL_TCL_DATA_CMD_INFO1_TCP6_CKSUM_EN
++
+ #define HAL_TCL_DATA_CMD_INFO0_DESC_TYPE	BIT(0)
+ #define HAL_TCL_DATA_CMD_INFO0_EPD		BIT(1)
+ #define HAL_TCL_DATA_CMD_INFO0_ENCAP_TYPE	GENMASK(3, 2)
+diff --git a/drivers/net/wireless/ath/ath11k/mac.c b/drivers/net/wireless/ath/ath11k/mac.c
+index 6942ebb..424553e 100644
+--- a/drivers/net/wireless/ath/ath11k/mac.c
++++ b/drivers/net/wireless/ath/ath11k/mac.c
+@@ -6784,6 +6784,9 @@ static void ath11k_mac_op_tx(struct ieee80211_hw *hw,
+ 
+ 	if (ar->ab->nss.enabled)
+ 		ret = ath11k_nss_tx(arvif, skb);
++	else if (info->flags & IEEE80211_TX_CTL_HW_80211_ENCAP)
++		ret = ath11k_dp_tx_simple(ar, arvif, skb,
++					  (control->sta) ? control->sta->drv_priv : NULL);
+ 	else
+ 		ret = ath11k_dp_tx(ar, arvif, skb,
+ 				   (control->sta) ? control->sta->drv_priv : NULL);
+-- 
+2.7.4
+
