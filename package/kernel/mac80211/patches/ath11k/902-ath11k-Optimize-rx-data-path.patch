From 60c40eb1890760428fd57b8b9cdd58d9fb245a6f Mon Sep 17 00:00:00 2001
From: Tamizh Chelvam <quic_tamizhr@quicinc.com>
Date: Mon, 15 Nov 2021 19:16:42 +0530
Subject: ath11k: Optimize rx data path

Adding following optimizations in rx data path to improve
performance in terms of CPU and throughput.

Signed-off-by: Tamizh Chelvam <quic_tamizhr@quicinc.com>
Change-Id: I5032a50d825abc3409679d18415e35169e9b2c42
---
 .../patches/336-0001-ath11k-idr-optimization.patch | 203 ++++++++++++++++++++
 .../patches/336-0002-ath11k-Use-idr_replace.patch  | 211 +++++++++++++++++++++
 ...th11k-Replenish-rx-desc-before-processing.patch |  55 ++++++
 3 files changed, 469 insertions(+)
 create mode 100644 mac80211/patches/336-0001-ath11k-idr-optimization.patch
 create mode 100644 mac80211/patches/336-0002-ath11k-Use-idr_replace.patch
 create mode 100644 mac80211/patches/336-0003-ath11k-Replenish-rx-desc-before-processing.patch

--- /dev/null
+++ b/mac80211/patches/336-0001-ath11k-idr-optimization.patch
@@ -0,0 +1,203 @@
+From 1f9cf7ea1d6ca455ff80b1c52ad3a5c7ffe2b691 Mon Sep 17 00:00:00 2001
+From: Tamizh Chelvam <quic_tamizhr@quicinc.com>
+Date: Mon, 15 Nov 2021 17:51:43 +0530
+Subject: [PATCH 1/4] ath11k: idr optimization
+
+Replace idr_find and idr_remove with idr_remove. As idr_remove
+itself will do idr_find. And use dma low level api.
+
+Signed-off-by: Tamizh Chelvam <quic_tamizhr@quicinc.com>
+---
+ backport-include/linux/idr.h            |  4 ++
+ drivers/net/wireless/ath/ath11k/dp_rx.c | 67 +++++++--------------------------
+ drivers/net/wireless/ath/ath11k/dp_tx.c |  2 +-
+ 3 files changed, 19 insertions(+), 54 deletions(-)
+
+--- a/backport-include/linux/idr.h
++++ b/backport-include/linux/idr.h
+@@ -65,6 +65,10 @@ static inline void idr_preload_end(void)
+ static inline void *backport_idr_remove(struct idr *idr, int id)
+ {
+ 	void *item = idr_find(idr, id);
++
++	if (!item)
++		return NULL;
++
+ 	idr_remove(idr, id);
+ 	return item;
+ }
+--- a/drivers/net/wireless/ath/ath11k/dp_rx.c
++++ b/drivers/net/wireless/ath/ath11k/dp_rx.c
+@@ -409,8 +409,8 @@ int ath11k_dp_rxbufs_replenish(struct at
+ 		}
+ 
+ 		paddr = dma_map_single(ab->dev, skb->data,
+-				       skb->len + skb_tailroom(skb),
+-				       DMA_FROM_DEVICE);
++				skb->len + skb_tailroom(skb),
++				DMA_FROM_DEVICE);
+ 		if (dma_mapping_error(ab->dev, paddr))
+ 			goto fail_free_skb;
+ 
+@@ -447,7 +447,7 @@ fail_idr_remove:
+ 	spin_unlock_bh(&rx_ring->idr_lock);
+ fail_dma_unmap:
+ 	dma_unmap_single(ab->dev, paddr, skb->len + skb_tailroom(skb),
+-			 DMA_FROM_DEVICE);
++			DMA_FROM_DEVICE);
+ fail_free_skb:
+ 	dev_kfree_skb_any(skb);
+ 
+@@ -3300,18 +3300,16 @@ try_again:
+ 		ar = ab->pdevs[mac_id].ar;
+ 		rx_ring = &ar->dp.rx_refill_buf_ring;
+ 		spin_lock_bh(&rx_ring->idr_lock);
+-		msdu = idr_find(&rx_ring->bufs_idr, buf_id);
++		msdu = idr_remove(&rx_ring->bufs_idr, buf_id);
++		spin_unlock_bh(&rx_ring->idr_lock);
+ 		if (unlikely(!msdu)) {
+ 			ath11k_warn(ab, "frame rx with invalid buf_id %d\n",
+ 				    buf_id);
+-			spin_unlock_bh(&rx_ring->idr_lock);
+ 			continue;
+ 		}
+ 
+-		idr_remove(&rx_ring->bufs_idr, buf_id);
+-		spin_unlock_bh(&rx_ring->idr_lock);
+-
+ 		rxcb = ATH11K_SKB_RXCB(msdu);
++
+ 		dma_unmap_single(ab->dev, rxcb->paddr,
+ 				 msdu->len + skb_tailroom(msdu),
+ 				 DMA_FROM_DEVICE);
+@@ -3861,7 +3859,7 @@ static int ath11k_dp_rx_reap_mon_status_
+ 			}
+ 
+ 			spin_lock_bh(&rx_ring->idr_lock);
+-			skb = idr_find(&rx_ring->bufs_idr, buf_id);
++			skb = idr_remove(&rx_ring->bufs_idr, buf_id);
+ 			spin_unlock_bh(&rx_ring->idr_lock);
+ 
+ 			if (!skb) {
+@@ -3894,10 +3892,6 @@ static int ath11k_dp_rx_reap_mon_status_
+ 				break;
+ 			}
+ 
+-			spin_lock_bh(&rx_ring->idr_lock);
+-			idr_remove(&rx_ring->bufs_idr, buf_id);
+-			spin_unlock_bh(&rx_ring->idr_lock);
+-
+ 			if (ab->hw_params.full_monitor_mode) {
+ 				ath11k_dp_rx_mon_update_status_buf_state(pmon, tlv);
+ 				if (paddr == pmon->mon_status_paddr)
+@@ -4659,17 +4653,14 @@ ath11k_dp_process_rx_err_buf(struct ath1
+ 	u32 hal_rx_desc_sz = ar->ab->hw_params.hal_desc_sz;
+ 
+ 	spin_lock_bh(&rx_ring->idr_lock);
+-	msdu = idr_find(&rx_ring->bufs_idr, buf_id);
++	msdu = idr_remove(&rx_ring->bufs_idr, buf_id);
++	spin_unlock_bh(&rx_ring->idr_lock);
+ 	if (!msdu) {
+ 		ath11k_warn(ar->ab, "rx err buf with invalid buf_id %d\n",
+ 			    buf_id);
+-		spin_unlock_bh(&rx_ring->idr_lock);
+ 		return -EINVAL;
+ 	}
+ 
+-	idr_remove(&rx_ring->bufs_idr, buf_id);
+-	spin_unlock_bh(&rx_ring->idr_lock);
+-
+ 	rxcb = ATH11K_SKB_RXCB(msdu);
+ 	dma_unmap_single(ar->ab->dev, rxcb->paddr,
+ 			 msdu->len + skb_tailroom(msdu),
+@@ -5090,18 +5081,16 @@ int ath11k_dp_rx_process_wbm_err(struct
+ 		rx_ring = &ar->dp.rx_refill_buf_ring;
+ 
+ 		spin_lock_bh(&rx_ring->idr_lock);
+-		msdu = idr_find(&rx_ring->bufs_idr, buf_id);
++ 		msdu = idr_remove(&rx_ring->bufs_idr, buf_id);
++		spin_unlock_bh(&rx_ring->idr_lock);
+ 		if (!msdu) {
+ 			ath11k_warn(ab, "frame rx with invalid buf_id %d pdev %d\n",
+ 				    buf_id, mac_id);
+-			spin_unlock_bh(&rx_ring->idr_lock);
+ 			continue;
+ 		}
+ 
+-		idr_remove(&rx_ring->bufs_idr, buf_id);
+-		spin_unlock_bh(&rx_ring->idr_lock);
+-
+ 		rxcb = ATH11K_SKB_RXCB(msdu);
++
+ 		dma_unmap_single(ab->dev, rxcb->paddr,
+ 				 msdu->len + skb_tailroom(msdu),
+ 				 DMA_FROM_DEVICE);
+@@ -5216,16 +5205,14 @@ int ath11k_dp_process_rxdma_err(struct a
+ 					   msdu_cookies[i]);
+ 
+ 			spin_lock_bh(&rx_ring->idr_lock);
+-			skb = idr_find(&rx_ring->bufs_idr, buf_id);
++			skb = idr_remove(&rx_ring->bufs_idr, buf_id);
++			spin_unlock_bh(&rx_ring->idr_lock);
+ 			if (!skb) {
+ 				ath11k_warn(ab, "rxdma error with invalid buf_id %d\n",
+ 					    buf_id);
+-				spin_unlock_bh(&rx_ring->idr_lock);
+ 				continue;
+ 			}
+ 
+-			idr_remove(&rx_ring->bufs_idr, buf_id);
+-			spin_unlock_bh(&rx_ring->idr_lock);
+ 
+ 			rxcb = ATH11K_SKB_RXCB(skb);
+ 			dma_unmap_single(ab->dev, rxcb->paddr,
+@@ -5739,7 +5726,7 @@ ath11k_dp_rx_mon_mpdu_pop(struct ath11k
+ 					   msdu_list.sw_cookie[i]);
+ 
+ 			spin_lock_bh(&rx_ring->idr_lock);
+-			msdu = idr_find(&rx_ring->bufs_idr, buf_id);
++			msdu = idr_remove(&rx_ring->bufs_idr, buf_id);
+ 			spin_unlock_bh(&rx_ring->idr_lock);
+ 			if (!msdu) {
+ 				ath11k_dbg(ar->ab, ATH11K_DBG_DATA,
+@@ -5810,9 +5797,6 @@ ath11k_dp_rx_mon_mpdu_pop(struct ath11k
+ next_msdu:
+ 			pmon->mon_last_buf_cookie = msdu_list.sw_cookie[i];
+ 			rx_bufs_used++;
+-			spin_lock_bh(&rx_ring->idr_lock);
+-			idr_remove(&rx_ring->bufs_idr, buf_id);
+-			spin_unlock_bh(&rx_ring->idr_lock);
+ 		}
+ 
+ 		ath11k_hal_rx_buf_addr_info_set(rx_link_buf_info, paddr, sw_cookie, rbm);
+@@ -6519,16 +6503,14 @@ ath11k_dp_rx_full_mon_mpdu_pop(struct at
+ 					   msdu_list.sw_cookie[i]);
+ 
+ 			spin_lock_bh(&rx_ring->idr_lock);
+-			msdu = idr_find(&rx_ring->bufs_idr, buf_id);
++			msdu = idr_remove(&rx_ring->bufs_idr, buf_id);
++			spin_unlock_bh(&rx_ring->idr_lock);
+ 			if (!msdu) {
+ 				ath11k_dbg(ar->ab, ATH11K_DBG_DATA,
+ 					   "full mon msdu_pop: invalid buf_id %d\n",
+ 					    buf_id);
+-				spin_unlock_bh(&rx_ring->idr_lock);
+ 				break;
+ 			}
+-			idr_remove(&rx_ring->bufs_idr, buf_id);
+-			spin_unlock_bh(&rx_ring->idr_lock);
+ 
+ 			rxcb = ATH11K_SKB_RXCB(msdu);
+ 			if (!rxcb->unmapped) {
+--- a/drivers/net/wireless/ath/ath11k/dp_tx.c
++++ b/drivers/net/wireless/ath/ath11k/dp_tx.c
+@@ -280,8 +280,8 @@ tcl_ring_sel:
+ 	spin_lock_bh(&tx_ring->tx_idr_lock);
+ 	idr = find_first_zero_bit(tx_ring->idrs, DP_TX_IDR_SIZE);
+ 	if (unlikely(idr >= DP_TX_IDR_SIZE)) {
+-		if (unlikely(ring_map == (BIT(max_tx_ring) - 1))) {
+ 			spin_unlock_bh(&tx_ring->tx_idr_lock);
++		if (unlikely(ring_map == (BIT(max_tx_ring) - 1))) {
+ 			ab->soc_stats.tx_err.idr_na[tcl_ring_id]++;
+ 			return -ENOSPC;
+ 		}
--- /dev/null
+++ b/mac80211/patches/336-0002-ath11k-Use-idr_replace.patch
@@ -0,0 +1,211 @@
+From 014d8dce36caf1cc2f482f808fbeccc19b2d125b Mon Sep 17 00:00:00 2001
+From: Tamizh Chelvam <quic_tamizhr@quicinc.com>
+Date: Mon, 15 Nov 2021 18:15:38 +0530
+Subject: [PATCH 2/4] ath11k: Use idr_replace
+
+idr_alloc has been done multiple times upon reaping the msdu
+using idr_remove. This idr_alloc would take more cpu, to redue
+the cpu usage call idr_replace by storing used buf_ids instead
+of calling idr_alloc during replenish.
+
+Signed-off-by: Tamizh Chelvam <quic_tamizhr@quicinc.com>
+---
+ drivers/net/wireless/ath/ath11k/core.h  |  2 ++
+ drivers/net/wireless/ath/ath11k/dp.c    |  4 ++--
+ drivers/net/wireless/ath/ath11k/dp_rx.c | 39 ++++++++++++++++++++++-----------
+ drivers/net/wireless/ath/ath11k/dp_rx.h |  2 +-
+ 4 files changed, 31 insertions(+), 16 deletions(-)
+
+--- a/drivers/net/wireless/ath/ath11k/core.h
++++ b/drivers/net/wireless/ath/ath11k/core.h
+@@ -859,6 +859,7 @@ struct ath11k {
+ 	enum wmi_phy_mode cfr_phymode;
+ 
+ 	struct ath11k_smart_ant_info smart_ant_info;
++	int buf_ids[200];
+ };
+ 
+ struct ath11k_band_cap {
+@@ -1142,6 +1143,7 @@ struct ath11k_base {
+ 	struct mutex base_ast_lock;
+ 	struct work_struct wmi_ast_work;
+ 	struct list_head wmi_ast_list;
++	int wbm_err_ids[200];
+ 
+ 	/* must be last */
+ 	u8 drv_priv[0] __aligned(sizeof(void *));
+--- a/drivers/net/wireless/ath/ath11k/dp.c
++++ b/drivers/net/wireless/ath/ath11k/dp.c
+@@ -895,7 +895,7 @@ int ath11k_dp_service_srng(struct ath11k
+ 	struct napi_struct *napi = &irq_grp->napi;
+ 	int grp_id = irq_grp->grp_id;
+ 	int work_done = 0;
+-	int i = 0, j;
++	int i = 0, j, ids[2] = {-1};
+ 	int tot_work_done = 0;
+ 	bool nss_offload;
+ 
+@@ -981,7 +981,7 @@ int ath11k_dp_service_srng(struct ath11k
+ 
+ 				ath11k_dp_rxbufs_replenish(ab, id, rx_ring, 0,
+ 							   HAL_RX_BUF_RBM_SW3_BM,
+-							   GFP_ATOMIC);
++							   GFP_ATOMIC, 0, ids);
+ 			}
+ 		}
+ 	}
+--- a/drivers/net/wireless/ath/ath11k/dp_rx.c
++++ b/drivers/net/wireless/ath/ath11k/dp_rx.c
+@@ -20,6 +20,7 @@
+ #include "nss.h"
+ 
+ #define ATH11K_DP_RX_FRAGMENT_TIMEOUT_MS (2 * HZ)
++int ids[200];
+ 
+ static inline u8 *ath11k_dp_rx_h_80211_hdr(struct ath11k_base *ab, struct hal_rx_desc *desc)
+ {
+@@ -369,7 +370,7 @@ int ath11k_dp_rxbufs_replenish(struct at
+ 			       struct dp_rxdma_ring *rx_ring,
+ 			       int req_entries,
+ 			       enum hal_rx_buf_return_buf_manager mgr,
+-			       gfp_t gfp)
++			       gfp_t gfp, bool replace, int buf_ids[])
+ {
+ 	struct hal_srng *srng;
+ 	u32 *desc;
+@@ -414,10 +415,16 @@ int ath11k_dp_rxbufs_replenish(struct at
+ 		if (dma_mapping_error(ab->dev, paddr))
+ 			goto fail_free_skb;
+ 
+-		spin_lock_bh(&rx_ring->idr_lock);
+-		buf_id = idr_alloc(&rx_ring->bufs_idr, skb, 0,
+-				   rx_ring->bufs_max * 3, GFP_ATOMIC);
+-		spin_unlock_bh(&rx_ring->idr_lock);
++		if (!replace) {
++			spin_lock_bh(&rx_ring->idr_lock);
++			buf_id = idr_alloc(&rx_ring->bufs_idr, skb, 0,
++					   rx_ring->bufs_max * 3, GFP_ATOMIC);
++			spin_unlock_bh(&rx_ring->idr_lock);
++		} else {
++			buf_id = buf_ids[num_remain - 1];
++			idr_replace(&rx_ring->bufs_idr, skb, buf_id);
++			buf_ids[num_remain - 1] = -1;
++		}
+ 		if (buf_id < 0)
+ 			goto fail_dma_unmap;
+ 
+@@ -513,7 +520,7 @@ static int ath11k_dp_rxdma_ring_buf_setu
+ 
+ 	rx_ring->bufs_max = num_entries;
+ 	ath11k_dp_rxbufs_replenish(ar->ab, dp->mac_id, rx_ring, num_entries,
+-				   HAL_RX_BUF_RBM_SW3_BM, GFP_KERNEL);
++				   HAL_RX_BUF_RBM_SW3_BM, GFP_KERNEL, 0, ids);
+ 	return 0;
+ }
+ 
+@@ -3300,13 +3307,15 @@ try_again:
+ 		ar = ab->pdevs[mac_id].ar;
+ 		rx_ring = &ar->dp.rx_refill_buf_ring;
+ 		spin_lock_bh(&rx_ring->idr_lock);
+-		msdu = idr_remove(&rx_ring->bufs_idr, buf_id);
++		msdu = idr_find(&rx_ring->bufs_idr, buf_id);
+ 		spin_unlock_bh(&rx_ring->idr_lock);
+ 		if (unlikely(!msdu)) {
+ 			ath11k_warn(ab, "frame rx with invalid buf_id %d\n",
+ 				    buf_id);
+ 			continue;
+ 		}
++		i = num_buffs_reaped[mac_id];
++		ar->buf_ids[i] = buf_id;
+ 
+ 		rxcb = ATH11K_SKB_RXCB(msdu);
+ 
+@@ -3392,7 +3401,7 @@ try_again:
+ 		rx_ring = &ar->dp.rx_refill_buf_ring;
+ 
+ 		ath11k_dp_rxbufs_replenish(ab, i, rx_ring, num_buffs_reaped[i],
+-					   HAL_RX_BUF_RBM_SW3_BM, GFP_ATOMIC);
++					   HAL_RX_BUF_RBM_SW3_BM, GFP_ATOMIC, true, ar->buf_ids);
+ 	}
+ 
+ exit:
+@@ -4815,7 +4824,7 @@ exit:
+ 		rx_ring = &ar->dp.rx_refill_buf_ring;
+ 
+ 		ath11k_dp_rxbufs_replenish(ab, i, rx_ring, n_bufs_reaped[i],
+-					   HAL_RX_BUF_RBM_SW3_BM, GFP_ATOMIC);
++					   HAL_RX_BUF_RBM_SW3_BM, GFP_ATOMIC, 0, ids);
+ 	}
+ 
+ 	return tot_n_bufs_reaped;
+@@ -5081,7 +5090,7 @@ int ath11k_dp_rx_process_wbm_err(struct
+ 		rx_ring = &ar->dp.rx_refill_buf_ring;
+ 
+ 		spin_lock_bh(&rx_ring->idr_lock);
+- 		msdu = idr_remove(&rx_ring->bufs_idr, buf_id);
++ 		msdu = idr_find(&rx_ring->bufs_idr, buf_id);
+ 		spin_unlock_bh(&rx_ring->idr_lock);
+ 		if (!msdu) {
+ 			ath11k_warn(ab, "frame rx with invalid buf_id %d pdev %d\n",
+@@ -5089,6 +5098,8 @@ int ath11k_dp_rx_process_wbm_err(struct
+ 			continue;
+ 		}
+ 
++		i = num_buffs_reaped[mac_id];
++		ab->wbm_err_ids[i] = buf_id;
+ 		rxcb = ATH11K_SKB_RXCB(msdu);
+ 
+ 		dma_unmap_single(ab->dev, rxcb->paddr,
+@@ -5126,7 +5137,7 @@ int ath11k_dp_rx_process_wbm_err(struct
+ 		rx_ring = &ar->dp.rx_refill_buf_ring;
+ 
+ 		ath11k_dp_rxbufs_replenish(ab, i, rx_ring, num_buffs_reaped[i],
+-					   HAL_RX_BUF_RBM_SW3_BM, GFP_ATOMIC);
++					   HAL_RX_BUF_RBM_SW3_BM, GFP_ATOMIC, 1, ab->wbm_err_ids);
+ 	}
+ 
+ 	rcu_read_lock();
+@@ -5233,7 +5244,7 @@ int ath11k_dp_process_rxdma_err(struct a
+ 
+ 	if (num_buf_freed)
+ 		ath11k_dp_rxbufs_replenish(ab, mac_id, rx_ring, num_buf_freed,
+-					   HAL_RX_BUF_RBM_SW3_BM, GFP_ATOMIC);
++					   HAL_RX_BUF_RBM_SW3_BM, GFP_ATOMIC, 0, ids);
+ 
+ 	return budget - quota;
+ }
+@@ -6243,12 +6254,12 @@ void ath11k_dp_rx_mon_dest_process(struc
+ 			ath11k_dp_rxbufs_replenish(ar->ab, dp->mac_id,
+ 						   &dp->rxdma_mon_buf_ring,
+ 						   rx_bufs_used,
+-						   HAL_RX_BUF_RBM_SW3_BM, GFP_ATOMIC);
++						   HAL_RX_BUF_RBM_SW3_BM, GFP_ATOMIC, 0, ids);
+ 		else
+ 			ath11k_dp_rxbufs_replenish(ar->ab, dp->mac_id,
+ 						   &dp->rx_refill_buf_ring,
+ 						   rx_bufs_used,
+-						   HAL_RX_BUF_RBM_SW3_BM, GFP_ATOMIC);
++						   HAL_RX_BUF_RBM_SW3_BM, GFP_ATOMIC, 0, ids);
+ 	}
+ }
+ 
+@@ -6781,7 +6792,7 @@ next_entry:
+ 		ath11k_dp_rxbufs_replenish(ar->ab, dp->mac_id,
+ 					   &dp->rxdma_mon_buf_ring,
+ 					   rx_bufs_used,
+-					   HAL_RX_BUF_RBM_SW3_BM, GFP_ATOMIC);
++					   HAL_RX_BUF_RBM_SW3_BM, GFP_ATOMIC, 0, ids);
+ 	}
+ 
+ reap_status_ring:
+--- a/drivers/net/wireless/ath/ath11k/dp_rx.h
++++ b/drivers/net/wireless/ath/ath11k/dp_rx.h
+@@ -126,7 +126,7 @@ int ath11k_dp_rxbufs_replenish(struct at
+ 			       struct dp_rxdma_ring *rx_ring,
+ 			       int req_entries,
+ 			       enum hal_rx_buf_return_buf_manager mgr,
+-			       gfp_t gfp);
++			       gfp_t gfp, bool replace, int ids[]);
+ int ath11k_dp_htt_tlv_iter(struct ath11k_base *ab, const void *ptr, size_t len,
+ 			   int (*iter)(struct ath11k_base *ar, u16 tag, u16 len,
+ 				       const void *ptr, void *data),
--- /dev/null
+++ b/mac80211/patches/336-0003-ath11k-Replenish-rx-desc-before-processing.patch
@@ -0,0 +1,55 @@
+From 298eb29ef990a3dc9385e4eccb88e444b2cfc031 Mon Sep 17 00:00:00 2001
+From: Tamizh Chelvam <quic_tamizhr@quicinc.com>
+Date: Mon, 15 Nov 2021 18:51:06 +0530
+Subject: [PATCH 4/4] ath11k: Replenish rx desc before processing
+
+Replenish rx desc before processing and ignore rxdma overflow
+error interrupts before adding to the list as we are dropping
+the rxdma overflow later.
+
+Signed-off-by: Tamizh Chelvam <quic_tamizhr@quicinc.com>
+---
+ drivers/net/wireless/ath/ath11k/dp_rx.c | 13 ++++++++++++-
+ 1 file changed, 12 insertions(+), 1 deletion(-)
+
+diff --git a/drivers/net/wireless/ath/ath11k/dp_rx.c b/drivers/net/wireless/ath/ath11k/dp_rx.c
+index a17a014..7597f2c 100644
+--- a/drivers/net/wireless/ath/ath11k/dp_rx.c
++++ b/drivers/net/wireless/ath/ath11k/dp_rx.c
+@@ -3483,7 +3483,6 @@ try_again:
+ 		if (!num_buffs_reaped[i])
+ 			continue;
+ 
+-		ath11k_dp_rx_process_received_packets(ab, napi, &msdu_list[i], i);
+ 		ar = ab->pdevs[i].ar;
+ 		rx_ring = &ar->dp.rx_refill_buf_ring;
+ 
+@@ -3491,6 +3490,12 @@ try_again:
+ 					   HAL_RX_BUF_RBM_SW3_BM, GFP_ATOMIC, true, ar->buf_ids);
+ 	}
+ 
++	for (i = 0; i < ab->num_radios; i++) {
++		if (!num_buffs_reaped[i])
++			continue;
++
++		ath11k_dp_rx_process_received_packets(ab, napi, &msdu_list[i], i);
++	}
+ exit:
+ 	return total_msdu_reaped;
+ }
+@@ -5200,6 +5205,12 @@ int ath11k_dp_rx_process_wbm_err(struct ath11k_base *ab,
+ 		total_num_buffs_reaped++;
+ 		budget--;
+ 
++ 		if (err_info.err_rel_src == HAL_WBM_REL_SRC_MODULE_RXDMA &&
++ 		    err_info.err_code != HAL_REO_ENTR_RING_RXDMA_ECODE_TKIP_MIC_ERR) {
++			ab->soc_stats.rxdma_error[err_info.err_code]++;
++ 			dev_kfree_skb_any(msdu);
++ 			continue;
++ 		}
+ 		if (err_info.push_reason !=
+ 		    HAL_REO_DEST_RING_PUSH_REASON_ERR_DETECTED) {
+ 			dev_kfree_skb_any(msdu);
+-- 
+2.7.4
+
